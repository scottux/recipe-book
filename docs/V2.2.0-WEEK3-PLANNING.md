# V2.2.0 Cloud Backup - Week 3 Planning
## Restore Functionality

**Date**: February 16, 2026  
**Version**: V2.2.0 (In Development)  
**Phase**: Week 3 - Restore from Cloud Backup  
**Status**: ðŸ“‹ Planning

---

## Overview

Week 3 focuses on implementing the restore functionality, allowing users to download and restore their Recipe Book data from cloud backups. This completes the backup/restore cycle started in Weeks 1-2.

---

## SDLC Phase 1: Planning

### Business Requirements

**Goal**: Enable users to restore their Recipe Book data from Dropbox backups

**Value Proposition**:
- Users can recover data after accidental deletion
- Users can restore data on new devices
- Users can rollback to previous state if needed
- Provides complete data safety net with backup feature

### User Stories (from REQ-021)

1. **As a user**, I want to view my backup history so that I know when my data was last backed up
2. **As a user**, I want to restore from a cloud backup so that I can recover my data if needed
3. **As a user**, I want to choose between "merge" and "replace" modes so that I have control over how data is restored
4. **As a user**, I want to preview backup contents before restoring so that I know what data I'm importing
5. **As a user**, I want password confirmation before restore so that accidental restores are prevented

### Success Criteria

- âœ… User can list available cloud backups
- âœ… User can download backup from Dropbox
- âœ… User can preview backup contents
- âœ… User can restore with "merge" mode (add to existing)
- âœ… User can restore with "replace" mode (delete existing)
- âœ… Password confirmation required for security
- âœ… Detailed import statistics displayed
- âœ… Rollback on failure (transaction safety)
- âœ… All edge cases handled gracefully

---

## SDLC Phase 2: Requirements Documentation

### Functional Requirements

#### FR-1: List Cloud Backups
- **Endpoint**: `GET /api/cloud/backups`
- **Response**: List of available backups with metadata
- **Sorting**: Newest first
- **Limit**: Configurable (default 10)
- **Already Implemented**: Yes (Week 2) âœ…

#### FR-2: Download Backup from Cloud
- **Service**: `dropboxService.downloadBackup(user, backupId)`
- **Process**:
  1. Verify user owns the backup
  2. Download from Dropbox to temp directory
  3. Verify file integrity (size, format)
  4. Return local file path
  5. Cleanup on error
- **Status**: To be implemented

#### FR-3: Parse and Validate Backup
- **Service**: `backupParser.parseBackup(filePath)`
- **Process**:
  1. Extract ZIP file
  2. Parse JSON content
  3. Validate structure
  4. Check version compatibility
  5. Return parsed data
- **Validation**:
  - Valid ZIP format
  - Valid JSON structure
  - Required fields present
  - Version compatibility
  - Data integrity
- **Status**: To be implemented

#### FR-4: Preview Backup Contents
- **Endpoint**: `GET /api/cloud/backups/:backupId/preview`
- **Response**:
  ```json
  {
    "success": true,
    "preview": {
      "version": "2.2.0",
      "exportDate": "2026-02-16T14:05:00Z",
      "type": "manual",
      "statistics": {
        "recipeCount": 50,
        "collectionCount": 3,
        "mealPlanCount": 2,
        "shoppingListCount": 1
      }
    }
  }
  ```
- **Status**: To be implemented

#### FR-5: Restore from Backup
- **Endpoint**: `POST /api/cloud/restore`
- **Request**:
  ```json
  {
    "backupId": "id:backup_123",
    "mode": "merge" | "replace",
    "password": "user_password"
  }
  ```
- **Process**:
  1. Verify password
  2. Download backup
  3. Parse and validate
  4. Begin transaction
  5. If mode === 'replace': Delete existing data
  6. Import data (reuse import logic from REQ-016)
  7. Commit transaction or rollback on error
  8. Cleanup temp files
  9. Return statistics
- **Status**: To be implemented

#### FR-6: Restore Modes

**Merge Mode**:
- Add backup items to existing data
- Skip duplicates (based on title/content hash)
- Preserve existing data
- Safe option (no data loss)

**Replace Mode**:
- Delete ALL existing user data
- Import all items from backup
- Complete reset to backup state
- Requires extra confirmation

#### FR-7: Password Verification
- Verify user password before restore
- Use bcrypt comparison (same as login)
- Return 401 if password incorrect
- Rate limit: 5 attempts per 15 minutes

#### FR-8: Transaction Safety
- Wrap restore in MongoDB transaction
- Rollback on any error
- All-or-nothing guarantee
- Error logged with details

---

## Technical Design

### Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚
â”‚  (Frontend) â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ POST /api/cloud/restore
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  cloudBackupController.restore()    â”‚
â”‚  â”œâ”€ Verify password                 â”‚
â”‚  â”œâ”€ Download from Dropbox            â”‚
â”‚  â”œâ”€ Parse & validate                â”‚
â”‚  â”œâ”€ Begin transaction               â”‚
â”‚  â”œâ”€ Delete existing (if replace)    â”‚
â”‚  â”œâ”€ Import data                     â”‚
â”‚  â”œâ”€ Commit or rollback              â”‚
â”‚  â””â”€ Return statistics               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â–¼             â–¼              â–¼             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Dropbox    â”‚ â”‚   Backup    â”‚ â”‚  Import  â”‚ â”‚  Models â”‚
    â”‚  Service    â”‚ â”‚   Parser    â”‚ â”‚Processor â”‚ â”‚(Recipe, â”‚
    â”‚             â”‚ â”‚             â”‚ â”‚          â”‚ â”‚ etc.)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### New Services

#### 1. Backup Parser Service
**File**: `backend/src/services/backupParser.js`

```javascript
/**
 * Parse and validate cloud backup files
 */

import fs from 'fs/promises';
import path from 'path';
import unzipper from 'unzipper';

/**
 * Parse a backup ZIP file
 * @param {string} filePath - Path to backup ZIP
 * @returns {Object} Parsed backup data
 */
export async function parseBackup(filePath) {
  // 1. Extract ZIP
  const extractDir = `${filePath}-extracted`;
  await extractZip(filePath, extractDir);
  
  // 2. Read JSON
  const jsonPath = path.join(extractDir, 'backup.json');
  const jsonContent = await fs.readFile(jsonPath, 'utf-8');
  const data = JSON.parse(jsonContent);
  
  // 3. Validate structure
  validateBackupStructure(data);
  
  // 4. Check version compatibility
  validateVersion(data.version);
  
  // 5. Cleanup extracted files
  await fs.rm(extractDir, { recursive: true, force: true });
  
  return data;
}

/**
 * Validate backup data structure
 */
function validateBackupStructure(data) {
  const required = ['version', 'exportDate', 'recipes'];
  for (const field of required) {
    if (!data[field]) {
      throw new Error(`Invalid backup: missing ${field}`);
    }
  }
}

/**
 * Check version compatibility
 */
function validateVersion(version) {
  const current = '2.2.0';
  const [major, minor] = version.split('.').map(Number);
  const [currentMajor] = current.split('.').map(Number);
  
  if (major > currentMajor) {
    throw new Error(`Backup from future version (${version}). Cannot import.`);
  }
}

/**
 * Extract ZIP file
 */
async function extractZip(zipPath, extractPath) {
  await fs.mkdir(extractPath, { recursive: true });
  
  await new Promise((resolve, reject) => {
    fs.createReadStream(zipPath)
      .pipe(unzipper.Extract({ path: extractPath }))
      .on('close', resolve)
      .on('error', reject);
  });
}

/**
 * Get backup preview (without full extraction)
 */
export async function getBackupPreview(filePath) {
  // Quick extraction of just metadata
  const data = await parseBackup(filePath);
  
  return {
    version: data.version,
    exportDate: data.exportDate,
    type: data.type,
    statistics: data.statistics
  };
}
```

#### 2. Backup Restorer Service
**File**: `backend/src/services/backupRestorer.js`

```javascript
/**
 * Restore data from cloud backups
 */

import mongoose from 'mongoose';
import Recipe from '../models/Recipe.js';
import Collection from '../models/Collection.js';
import MealPlan from '../models/MealPlan.js';
import ShoppingList from '../models/ShoppingList.js';
import { processImport } from './importProcessor.js';

/**
 * Restore from backup data
 * @param {string} userId - User ID
 * @param {Object} backupData - Parsed backup data
 * @param {string} mode - 'merge' or 'replace'
 * @returns {Object} Import statistics
 */
export async function restoreFromBackup(userId, backupData, mode) {
  const session = await mongoose.startSession();
  
  try {
    await session.startTransaction();
    
    let stats;
    
    if (mode === 'replace') {
      // Delete all existing data
      await deleteExistingData(userId, session);
      
      // Import all from backup
      stats = await importBackupData(userId, backupData, session);
    } else {
      // Merge mode: Import with duplicate checking
      stats = await importBackupData(userId, backupData, session, true);
    }
    
    await session.commitTransaction();
    return stats;
    
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}

/**
 * Delete all existing user data
 */
async function deleteExistingData(userId, session) {
  await Promise.all([
    Recipe.deleteMany({ owner: userId }).session(session),
    Collection.deleteMany({ owner: userId }).session(session),
    MealPlan.deleteMany({ owner: userId }).session(session),
    ShoppingList.deleteMany({ owner: userId }).session(session)
  ]);
}

/**
 * Import backup data
 */
async function importBackupData(userId, backupData, session, checkDuplicates = false) {
  // Reuse existing import logic from REQ-016
  const importData = {
    recipes: backupData.recipes || [],
    collections: backupData.collections || [],
    mealPlans: backupData.mealPlans || [],
    shoppingLists: backupData.shoppingLists || []
  };
  
  return await processImport(userId, importData, session, checkDuplicates);
}
```

### Updated Controller

**File**: `backend/src/controllers/cloudBackupController.js`

Add new methods:

```javascript
/**
 * Preview backup contents
 */
export async function previewBackup(req, res) {
  try {
    const { backupId } = req.params;
    const user = await User.findById(req.user.userId);
    
    if (!user.cloudBackup?.provider) {
      return res.status(400).json({
        success: false,
        message: 'No cloud provider connected'
      });
    }
    
    // Download backup temporarily
    const tempFile = await dropboxService.downloadBackup(user, backupId);
    
    // Get preview
    const preview = await getBackupPreview(tempFile);
    
    // Cleanup
    await fs.unlink(tempFile);
    
    res.json({
      success: true,
      preview
    });
    
  } catch (error) {
    logger.error('Preview backup failed', { error: error.message });
    res.status(500).json({
      success: false,
      message: 'Failed to preview backup'
    });
  }
}

/**
 * Restore from cloud backup
 */
export async function restoreFromCloudBackup(req, res) {
  try {
    const { backupId, mode, password } = req.body;
    
    // Validate input
    if (!backupId || !mode || !password) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: backupId, mode, password'
      });
    }
    
    if (!['merge', 'replace'].includes(mode)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid mode. Use "merge" or "replace"'
      });
    }
    
    // Get user
    const user = await User.findById(req.user.userId);
    
    if (!user.cloudBackup?.provider) {
      return res.status(400).json({
        success: false,
        message: 'No cloud provider connected'
      });
    }
    
    // Verify password
    const passwordValid = await bcrypt.compare(password, user.password);
    if (!passwordValid) {
      return res.status(401).json({
        success: false,
        message: 'Invalid password'
      });
    }
    
    logger.info(`Restore requested for user ${user._id}: backup=${backupId}, mode=${mode}`);
    
    // Download backup
    const tempFile = await dropboxService.downloadBackup(user, backupId);
    
    try {
      // Parse backup
      const backupData = await parseBackup(tempFile);
      
      // Restore data
      const statistics = await restoreFromBackup(user._id, backupData, mode);
      
      logger.info(`Restore successful for user ${user._id}`, { statistics });
      
      res.json({
        success: true,
        statistics,
        message: `Successfully restored ${statistics.totalImported} items`
      });
      
    } finally {
      // Cleanup temp file
      await fs.unlink(tempFile);
    }
    
  } catch (error) {
    logger.error('Restore failed', { error: error.message, stack: error.stack });
    
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to restore from backup'
    });
  }
}
```

### Updated Routes

**File**: `backend/src/routes/cloud.js`

```javascript
// Preview backup
router.get('/backups/:backupId/preview', authenticate, previewBackup);

// Restore from backup (update from 501 stub)
router.post('/restore', authenticate, restoreFromCloudBackup);
```

### Dependencies

**New Package**:
- `unzipper@0.12.3` - Extract ZIP files

**Installation**:
```bash
cd backend
npm install unzipper
```

---

## Testing Strategy

### Integration Tests

Update `cloud-backup.test.js` with restore tests:

```javascript
describe('Cloud Backup API - Restore Operations', () => {
  
  describe('GET /api/cloud/backups/:backupId/preview', () => {
    it('should preview backup contents', async () => {
      // Mock download and parse
      // Verify preview structure
    });
    
    it('should require cloud provider connection', async () => {
      // Test without provider
    });
  });
  
  describe('POST /api/cloud/restore', () => {
    it('should restore with merge mode', async () => {
      // Create existing data
      // Restore backup
      // Verify merge behavior (no data loss)
      // Check statistics
    });
    
    it('should restore with replace mode', async () => {
      // Create existing data
      // Restore backup
      // Verify existing data deleted
      // Verify backup data imported
      // Check statistics
    });
    
    it('should require password verification', async () => {
      // Try restore with wrong password
      // Expect 401
    });
    
    it('should rollback on error', async () => {
      // Mock error during import
      // Verify transaction rolled back
      // Verify existing data intact
    });
    
    it('should validate mode parameter', async () => {
      // Try invalid mode
      // Expect 400
    });
    
    it('should handle corrupted backup files', async () => {
      // Mock corrupted ZIP
      // Expect graceful error
    });
    
    it('should handle version incompatibility', async () => {
      // Mock future version backup
      // Expect version error
    });
  });
});
```

### Test Scenarios

1. **Happy Path - Merge Mode**
   - User has 10 existing recipes
   - Backup contains 15 recipes (5 duplicates)
   - After restore: 20 unique recipes
   - Statistics: imported=10, skipped=5

2. **Happy Path - Replace Mode**
   - User has 10 existing recipes
   - Backup contains 15 recipes
   - After restore: 15 recipes (existing deleted)
   - Statistics: imported=15, skipped=0

3. **Password Verification**
   - Wrong password â†’ 401
   - Rate limiting: 5 attempts per 15 min

4. **Error Handling**
   - Corrupted ZIP â†’ Clear error message
   - Invalid JSON â†’ Clear error message
   - Network error â†’ Retry logic
   - Transaction rollback â†’ Data intact

5. **Edge Cases**
   - Empty backup â†’ Import 0 items
   - Huge backup â†’ Performance test
   - Concurrent restores â†’ Prevent race conditions

---

## Implementation Plan

### Day 1-2: Service Development
- âœ… Install `unzipper` dependency
- âœ… Create `backupParser.js`
  - ZIP extraction
  - JSON parsing
  - Validation logic
  - Version checking
- âœ… Create `backupRestorer.js`
  - Transaction handling
  - Delete logic (replace mode)
  - Import logic (reuse from REQ-016)
- âœ… Unit tests for services

### Day 3-4: Controller & Routes
- âœ… Implement `previewBackup()`
- âœ… Implement `restoreFromCloudBackup()`
  - Password verification
  - Download orchestration
  - Mode handling
  - Error handling
- âœ… Update routes
- âœ… Integration tests

### Day 5: Dropbox Download
- âœ… Implement `dropboxService.downloadBackup()`
- âœ… File integrity checks
- âœ… Temp file management
- âœ… Error handling

### Day 6: Testing & Refinement
- âœ… Run full test suite
- âœ… Fix any failing tests
- âœ… Test edge cases
- âœ… Performance testing
- âœ… Documentation

### Day 7: Code Review & Documentation
- âœ… Self code review
- âœ… Update CHANGELOG
- âœ… Create week summary document
- âœ… Prepare for Week 4

---

## Acceptance Criteria

All criteria from REQ-021 FR-3:

- [ ] User can view available cloud backups âœ… (Week 2)
- [ ] User can preview backup contents before restoring
- [ ] User can restore with "merge" mode (add to existing)
- [ ] User can restore with "replace" mode (delete existing)
- [ ] Password confirmation required before restore
- [ ] Detailed import statistics displayed
- [ ] Transaction safety (rollback on failure)
- [ ] Corrupted backups detected and rejected
- [ ] Version incompatibility handled gracefully
- [ ] All tests passing (30+ tests expected)

---

## Risk Assessment

### Technical Risks

**Risk 1: Transaction Rollback Performance**
- **Impact**: High
- **Probability**: Medium
- **Mitigation**: Test with large datasets, optimize deletion queries

**Risk 2: ZIP File Corruption**
- **Impact**: Medium
- **Probability**: Low
- **Mitigation**: Checksum validation, graceful error messages

**Risk 3: Version Incompatibility**
- **Impact**: Medium
- **Probability**: Medium
- **Mitigation**: Clear version checking, migration guides

### Schedule Risks

**Risk 1: Complexity Underestimation**
- **Impact**: Medium
- **Probability**: Low
- **Mitigation**: 7-day schedule has buffer, can extend to Week 4 if needed

---

## Success Metrics

- âœ… All acceptance criteria met
- âœ… 90%+ test coverage for restore functionality
- âœ… < 30 seconds restore time for typical dataset (100 recipes)
- âœ… 0 data loss incidents in testing
- âœ… Transaction rollback works 100% of time on error

---

## Next Steps After Week 3

### Week 4: Automatic Backups
- Background job scheduler (node-cron)
- Schedule configuration UI
- Email notifications on backup failure
- Automatic cleanup of old backups

### Week 5: Google Drive Integration
- Google OAuth flow
- Google Drive upload/download
- Provider switching
- Unified provider interface

### Week 6: Frontend
- Cloud Backup page UI
- OAuth popup flow
- Backup history table
- Restore modal with preview
- Schedule configuration

---

## Documentation Requirements

- âœ… REQ-021 updated with implementation notes
- âœ… API documentation updated
- âœ… README updated with restore instructions
- âœ… Week 3 summary document created
- âœ… Code comments and JSDoc

---

**Document Version**: 1.0  
**Last Updated**: February 16, 2026  
**Next Review**: After Week 3 implementation  
**Status**: Ready for Implementation