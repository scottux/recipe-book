# V2.1.5 Design Document: Performance & Infrastructure

**Version**: 2.1.5  
**Status**: DRAFT  
**Created**: February 15, 2026  
**Author**: Development Team

---

## Table of Contents

1. [Overview](#overview)
2. [System Architecture](#system-architecture)
3. [Component Design](#component-design)
4. [Database Design](#database-design)
5. [API Design](#api-design)
6. [Frontend Architecture](#frontend-architecture)
7. [Infrastructure Design](#infrastructure-design)
8. [Security Considerations](#security-considerations)
9. [Performance Optimizations](#performance-optimizations)
10. [Testing Strategy](#testing-strategy)
11. [Deployment Architecture](#deployment-architecture)

---

## Overview

This document details the design and architecture for V2.1.5, which focuses on:
- Redis-based distributed rate limiting
- OpenTelemetry instrumentation with OpenObserve
- Structured logging with Winston
- Health check endpoints
- Performance optimizations
- Production-ready infrastructure

### Design Goals

1. **Scalability**: Support horizontal scaling with multiple backend instances
2. **Observability**: Comprehensive logging, metrics, and tracing
3. **Performance**: Sub-150ms API response times, optimized frontend
4. **Reliability**: 99.9% uptime with graceful degradation
5. **Maintainability**: Clear architecture, well-documented code

---

## System Architecture

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                          Load Balancer                           │
│                     (nginx/Kubernetes Ingress)                   │
└─────────────────────────┬───────────────────────────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
        ▼                 ▼                 ▼
┌───────────────┐ ┌───────────────┐ ┌───────────────┐
│  Backend API  │ │  Backend API  │ │  Backend API  │
│  Instance 1   │ │  Instance 2   │ │  Instance 3   │
└───────┬───────┘ └───────┬───────┘ └───────┬───────┘
        │                 │                 │
        └─────────────────┼─────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
        ▼                 ▼                 ▼
┌───────────────┐ ┌───────────────┐ ┌───────────────┐
│   MongoDB     │ │     Redis     │ │  OpenObserve  │
│   Cluster     │ │   (Primary +  │ │  (Logs/Traces │
│              │ │    Replica)   │ │   /Metrics)   │
└───────────────┘ └───────────────┘ └───────────────┘
```

### Data Flow

```
1. Request Flow:
   Client → Load Balancer → Backend API → Database/Redis

2. Observability Flow:
   Backend/Frontend → OpenTelemetry SDK → OTLP → OpenObserve

3. Rate Limiting Flow:
   Request → Rate Limit Middleware → Redis Check → Allow/Deny
```

---

## Component Design

### 1. Redis Rate Limiter

**File**: `backend/src/middleware/redisRateLimiter.js`

**Architecture**:
```javascript
┌─────────────────────────────────────────────────────┐
│           Redis Rate Limiter Middleware              │
├─────────────────────────────────────────────────────┤
│                                                      │
│  ┌─────────────┐      ┌──────────────┐            │
│  │   Extract   │─────→│  Build Key   │            │
│  │ Identifier  │      │ (IP/User ID) │            │
│  └─────────────┘      └──────┬───────┘            │
│                               │                     │
│                               ▼                     │
│                      ┌─────────────────┐           │
│                      │  Redis INCR +   │           │
│                      │  SET EXPIRY     │           │
│                      └────────┬────────┘           │
│                               │                     │
│              ┌────────────────┴────────────────┐   │
│              │                                  │   │
│              ▼                                  ▼   │
│      ┌──────────────┐                  ┌──────────┐│
│      │ Count <= Max │                  │Count > Max││
│      │  Allow Req   │                  │ Deny (429)││
│      └──────────────┘                  └──────────┘│
│              │                                  │   │
│              └──────────────┬──────────────────┘   │
│                             │                       │
│                             ▼                       │
│                    ┌─────────────────┐             │
│                    │  Add Rate Limit │             │
│                    │     Headers     │             │
│                    └─────────────────┘             │
└─────────────────────────────────────────────────────┘
```

**Key Structure**:
```
recipe-book:ratelimit:{endpoint}:{identifier}
Examples:
- recipe-book:ratelimit:/api/recipes:192.168.1.1
- recipe-book:ratelimit:/api/auth/login:user123
```

**Implementation**:
```javascript
class RedisRateLimiter {
  constructor(redis, options) {
    this.redis = redis;
    this.windowMs = options.windowMs || 900000; // 15 min
    this.maxRequests = options.maxRequests || 100;
    this.prefix = options.prefix || 'recipe-book:ratelimit:';
  }

  async checkLimit(identifier, endpoint) {
    const key = `${this.prefix}${endpoint}:${identifier}`;
    const current = await this.redis.incr(key);
    
    if (current === 1) {
      await this.redis.pexpire(key, this.windowMs);
    }
    
    const ttl = await this.redis.pttl(key);
    
    return {
      allowed: current <= this.maxRequests,
      limit: this.maxRequests,
      remaining: Math.max(0, this.maxRequests - current),
      resetTime: Date.now() + ttl
    };
  }

  middleware() {
    return async (req, res, next) => {
      const identifier = req.user?.id || req.ip;
      const endpoint = req.path;
      
      try {
        const result = await this.checkLimit(identifier, endpoint);
        
        res.setHeader('X-RateLimit-Limit', result.limit);
        res.setHeader('X-RateLimit-Remaining', result.remaining);
        res.setHeader('X-RateLimit-Reset', result.resetTime);
        
        if (!result.allowed) {
          res.setHeader('Retry-After', Math.ceil((result.resetTime - Date.now()) / 1000));
          return res.status(429).json({ 
            error: 'Too many requests',
            retryAfter: result.resetTime
          });
        }
        
        next();
      } catch (error) {
        // If Redis fails, allow request through (fail-open)
        logger.error('Rate limiter error', { error });
        next();
      }
    };
  }
}
```

**Fallback Strategy**:
- If Redis is unavailable: Allow requests (fail-open)
- Log errors to monitors
- Consider in-memory fallback for critical endpoints

---

### 2. OpenTelemetry Instrumentation

**File**: `backend/src/config/telemetry.js`

**Architecture**:
```
┌──────────────────────────────────────────────────┐
│         OpenTelemetry SDK Initialization          │
├──────────────────────────────────────────────────┤
│                                                   │
│  ┌────────────────┐    ┌──────────────────────┐ │
│  │   Resource     │    │  Auto-Instrumentation│ │
│  │   Attributes   │    │  - HTTP              │ │
│  │                │    │  - Express           │ │
│  │ - service.name │    │  - MongoDB           │ │
│  │ - service.ver  │    │  - Redis             │ │
│  │ - deployment   │    │  - DNS               │ │
│  └────────┬───────┘    └──────────┬───────────┘ │
│           │                       │              │
│           └───────────┬───────────┘              │
│                       ▼                          │
│           ┌──────────────────────┐               │
│           │  Trace Provider      │               │
│           │  - Sampler Config    │               │
│           │  - Batch Processor   │               │
│           └──────────┬───────────┘               │
│                      │                           │
│                      ▼                           │
│           ┌──────────────────────┐               │
│           │  Metrics Provider    │               │
│           │  - Periodic Reader   │               │
│           │  - Aggregation       │               │
│           └──────────┬───────────┘               │
│                      │                           │
│                      ▼                           │
│           ┌──────────────────────┐               │
│           │  OTLP Exporters      │               │
│           │  - Traces → O11y     │               │
│           │  - Metrics → O11y    │               │
│           │  - Logs → O11y       │               │
│           └──────────────────────┘               │
└──────────────────────────────────────────────────┘
```

**Implementation**:
```javascript
// backend/src/config/telemetry.js
const { NodeSDK } = require('@opentelemetry/sdk-node');
const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');
const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-http');
const { OTLPMetricExporter } = require('@opentelemetry/exporter-metrics-otlp-http');
const { Resource } = require('@opentelemetry/resources');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');

function initializeTelemetry() {
  const resource = new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: process.env.OTEL_SERVICE_NAME || 'recipe-book-api',
    [SemanticResourceAttributes.SERVICE_VERSION]: require('../../package.json').version,
    [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV,
  });

  const sdk = new NodeSDK({
    resource,
    traceExporter: new OTLPTraceExporter({
      url: `${process.env.OTEL_EXPORTER_OTLP_ENDPOINT}/v1/traces`,
      headers: parseHeaders(process.env.OTEL_EXPORTER_OTLP_HEADERS),
    }),
    metricReader: new PeriodicExportingMetricReader({
      exporter: new OTLPMetricExporter({
        url: `${process.env.OTEL_EXPORTER_OTLP_ENDPOINT}/v1/metrics`,
        headers: parseHeaders(process.env.OTEL_EXPORTER_OTLP_HEADERS),
      }),
      exportIntervalMillis: 60000, // 1 minute
    }),
    instrumentations: [
      getNodeAutoInstrumentations({
        '@opentelemetry/instrumentation-http': {
          ignoreIncomingPaths: ['/health/live', '/health/ready'],
        },
        '@opentelemetry/instrumentation-express': {
          enabled: true,
        },
        '@opentelemetry/instrumentation-mongodb': {
          enabled: true,
        },
      }),
    ],
  });

  sdk.start();

  // Graceful shutdown
  process.on('SIGTERM', () => {
    sdk.shutdown()
      .then(() => console.log('Telemetry shut down'))
      .catch((error) => console.error('Error shutting down telemetry', error))
      .finally(() => process.exit(0));
  });

  return sdk;
}

module.exports = { initializeTelemetry };
```

**Custom Spans**:
```javascript
const { trace } = require('@opentelemetry/api');

function createSpan(name, callback) {
  const tracer = trace.getTracer('recipe-book');
  const span = tracer.startSpan(name);
  
  try {
    const result = callback(span);
    span.setStatus({ code: SpanStatusCode.OK });
    return result;
  } catch (error) {
    span.recordException(error);
    span.setStatus({ 
      code: SpanStatusCode.ERROR,
      message: error.message 
    });
    throw error;
  } finally {
    span.end();
  }
}

// Usage in controller
async function getRecipes(req, res) {
  return createSpan('getRecipes', async (span) => {
    span.setAttribute('user.id', req.user.id);
    span.setAttribute('query.limit', req.query.limit || 10);
    
    const recipes = await Recipe.find({ owner: req.user.id });
    span.setAttribute('result.count', recipes.length);
    
    res.json(recipes);
  });
}
```

---

### 3. Winston Logging

**File**: `backend/src/config/logger.js`

**Architecture**:
```
┌─────────────────────────────────────────────────┐
│              Winston Logger Config               │
├─────────────────────────────────────────────────┤
│                                                  │
│  ┌───────────┐     ┌──────────────────────┐    │
│  │   Format  │────→│   JSON Formatter     │    │
│  │  Pipeline │     │   - timestamp        │    │
│  │           │     │   - level            │    │
│  │           │     │   - message          │    │
│  │           │     │   - metadata         │    │
│  └───────────┘     └──────────┬───────────┘    │
│                                │                 │
│                                ▼                 │
│                    ┌──────────────────────┐     │
│                    │  Sensitive Filter    │     │
│                    │  - Redact passwords  │     │
│                    │  - Redact tokens     │     │
│                    └──────────┬───────────┘     │
│                               │                  │
│               ┌───────────────┼────────────┐    │
│               │               │            │     │
│               ▼               ▼            ▼     │
│      ┌─────────────┐  ┌──────────┐ ┌──────────┐│
│      │   Console   │  │  File    │ │  File    ││
│      │ (dev only)  │  │ (error)  │ │(combined)││
│      └─────────────┘  └──────────┘ └──────────┘│
│                                                  │
└─────────────────────────────────────────────────┘
```

**Implementation**:
```javascript
// backend/src/config/logger.js
const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');

// Custom format to redact sensitive data
const redactSensitive = winston.format((info) => {
  if (info.password) info.password = '[REDACTED]';
  if (info.token) info.token = '[REDACTED]';
  if (info.authorization) info.authorization = '[REDACTED]';
  return info;
});

// Create logger
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    redactSensitive(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: 'recipe-book-api',
    environment: process.env.NODE_ENV,
  },
  transports: [
    // Error log
    new DailyRotateFile({
      level: 'error',
      filename: `${process.env.LOG_FILE_PATH}/error-%DATE%.log`,
      datePattern: process.env.LOG_DATE_PATTERN || 'YYYY-MM-DD',
      maxSize: process.env.LOG_MAX_SIZE || '20m',
      maxFiles: process.env.LOG_MAX_FILES || '14d',
      zippedArchive: true,
    }),
    
    // Combined log
    new DailyRotateFile({
      filename: `${process.env.LOG_FILE_PATH}/combined-%DATE%.log`,
      datePattern: process.env.LOG_DATE_PATTERN || 'YYYY-MM-DD',
      maxSize: process.env.LOG_MAX_SIZE || '20m',
      maxFiles: process.env.LOG_MAX_FILES || '14d',
      zippedArchive: true,
    }),
  ],
});

// Console transport for development
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    ),
  }));
}

module.exports = logger;
```

**Request Logging Middleware**:
```javascript
// backend/src/middleware/requestLogger.js
const expressWinston = require('express-winston');
const { v4: uuidv4 } = require('uuid');

// Add request ID middleware
const requestId = (req, res, next) => {
  req.id = uuidv4();
  res.setHeader('X-Request-ID', req.id);
  next();
};

// Request logging middleware
const requestLogger = expressWinston.logger({
  winstonInstance: logger,
  meta: true,
  msg: 'HTTP {{req.method}} {{req.url}}',
  expressFormat: false,
  colorize: false,
  dynamicMeta: (req, res) => ({
    requestId: req.id,
    userId: req.user?.id,
    ip: req.ip,
    userAgent: req.get('user-agent'),
  }),
});

module.exports = { requestId, requestLogger };
```

---

### 4. Health Check Endpoints

**File**: `backend/src/routes/health.js`

**Architecture**:
```
┌────────────────────────────────────────────┐
│         Health Check System                 │
├────────────────────────────────────────────┤
│                                             │
│  GET /health/live                          │
│  ┌──────────────────────────────────────┐ │
│  │ - Check: Process running              │ │
│  │ - No external dependencies            │ │
│  │ - Response time: <50ms                │ │
│  │ - Always returns 200 unless crashed   │ │
│  └──────────────────────────────────────┘ │
│                                             │
│  GET /health/ready                         │
│  ┌──────────────────────────────────────┐ │
│  │ - Check: Database connection          │ │
│  │ - Check: Redis connection (optional)  │ │
│  │ - Response time: <5000ms              │ │
│  │ - Returns 503 if dependencies down    │ │
│  └──────────────────────────────────────┘ │
│                                             │
│  GET /health/startup                       │
│  ┌──────────────────────────────────────┐ │
│  │ - Check: Application initialized      │ │
│  │ - Check: Services ready               │ │
│  │ - Used during container startup       │ │
│  └──────────────────────────────────────┘ │
└────────────────────────────────────────────┘
```

**Implementation**:
```javascript
// backend/src/routes/health.js
const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');
const redis = require('../config/redis');

// Liveness probe - simple check
router.get('/live', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: require('../../package.json').version,
  });
});

// Readiness probe - check dependencies
router.get('/ready', async (req, res) => {
  const checks = {
    database: 'unknown',
    redis: 'unknown',
  };
  
  try {
    // Check MongoDB
    if (mongoose.connection.readyState === 1) {
      await mongoose.connection.db.admin().ping();
      checks.database = 'ok';
    } else {
      checks.database = 'not_connected';
    }
    
    // Check Redis (optional, don't fail if Redis is down)
    try {
      await redis.ping();
      checks.redis = 'ok';
    } catch (error) {
      checks.redis = 'degraded';
      logger.warn('Redis health check failed', { error });
    }
    
    // Determine overall status
    const isHealthy = checks.database === 'ok';
    const statusCode = isHealthy ? 200 : 503;
    
    res.status(statusCode).json({
      status: isHealthy ? 'ok' : 'unhealthy',
      timestamp: new Date().toISOString(),
      checks,
    });
  } catch (error) {
    logger.error('Health check failed', { error });
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      checks,
      error: error.message,
    });
  }
});

// Startup probe
router.get('/startup', (req, res) => {
  const isStarted = mongoose.connection.readyState === 1;
  res.status(isStarted ? 200 : 503).json({
    status: isStarted ? 'started' : 'starting',
    timestamp: new Date().toISOString(),
  });
});

module.exports = router;
```

---

## Database Design

### Index Strategy

**New Indexes**:
```javascript
// User model
userSchema.index({ resetPasswordToken: 1 }, { 
  sparse: true,
  partialFilterExpression: { resetPasswordToken: { $exists: true } }
});

// Recipe model
recipeSchema.index({ owner: 1, createdAt: -1 }); // User's recent recipes
recipeSchema.index({ owner: 1, title: 1 }); // Search by title
recipeSchema.index({ tags: 1 }); // Filter by tags
recipeSchema.index({ cuisine: 1 }); // Filter by cuisine
recipeSchema.index({ dishType: 1 }); // Filter by dish type

// Collection model
collectionSchema.index({ owner: 1, name: 1 }); // User's collections

// MealPlan model
mealPlanSchema.index({ owner: 1, startDate: 1, endDate: 1 }); // Date range queries

// ShoppingList model
shoppingListSchema.index({ owner: 1, isActive: 1 }); // Active lists
```

**Index Analysis**:
```javascript
// Use explain to verify index usage
const explain = await Recipe.find({ owner: userId })
  .sort({ createdAt: -1 })
  .explain('executionStats');

console.log('Index used:', explain.executionStats.executionStages.indexName);
console.log('Docs examined:', explain.executionStats.totalDocsExamined);
console.log('Docs returned:', explain.executionStats.nReturned);
```

**Connection Pool Configuration**:
```javascript
mongoose.connect(process.env.MONGODB_URI, {
  minPoolSize: parseInt(process.env.DB_CONNECTION_POOL_MIN) || 10,
  maxPoolSize: parseInt(process.env.DB_CONNECTION_POOL_MAX) || 50,
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
});
```

---

## API Design

### Rate Limit Headers

All API responses will include:
```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1645000000000
X-Request-ID: abc123-def456-ghi789
```

When rate limited:
```
HTTP/1.1 429 Too Many Requests
Retry-After: 300
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1645000000000

{
  "error": "Too many requests",
  "retryAfter": 1645000000000
}
```

### Health Endpoints

```
GET /health/live
Response: 200 OK
{
  "status": "ok",
  "timestamp": "2026-02-15T20:00:00.000Z",
  "uptime": 3600,
  "version": "2.1.5"
}

GET /health/ready
Response: 200 OK or 503 Service Unavailable
{
  "status": "ok",
  "timestamp": "2026-02-15T20:00:00.000Z",
  "checks": {
    "database": "ok",
    "redis": "ok"
  }
}
```

---

## Frontend Architecture

### Code Splitting Strategy

```javascript
// App.jsx - Route-based code splitting
import { lazy, Suspense } from 'react';

const RecipeList = lazy(() => import('./components/RecipeList'));
const RecipeDetail = lazy(() => import('./components/RecipeDetail'));
const AddRecipePage = lazy(() => import('./components/AddRecipePage'));
const CollectionsPage = lazy(() => import('./components/CollectionsPage'));
const MealPlanningPage = lazy(() => import('./components/MealPlanningPage'));
const ShoppingListsPage = lazy(() => import('./components/ShoppingListsPage'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/" element={<RecipeList />} />
        <Route path="/recipe/:id" element={<RecipeDetail />} />
        <Route path="/add" element={<AddRecipePage />} />
        <Route path="/collections" element={<CollectionsPage />} />
        <Route path="/meal-planning" element={<MealPlanningPage />} />
        <Route path="/shopping-lists" element={<ShoppingListsPage />} />
      </Routes>
    </Suspense>
  );
}
```

### Bundle Optimization

**Vite Configuration**:
```javascript
// vite.config.js
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['react', 'react-dom', 'react-router-dom'],
          'ui': ['@headlessui/react', '@heroicons/react'],
        },
      },
    },
    chunkSizeWarningLimit: 200, // KB
  },
});
```

### OpenTelemetry Frontend

```javascript
// frontend/src/telemetry.js
import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { FetchInstrumentation } from '@opentelemetry/instrumentation-fetch';
import { UserInteractionInstrumentation } from '@opentelemetry/instrumentation-user-interaction';

const provider = new WebTracerProvider({
  resource: new Resource({
    'service.name': 'recipe-book-frontend',
    'service.version': '2.1.5',
  }),
});

provider.addSpanProcessor(
  new BatchSpanProcessor(
    new OTLPTraceExporter({
      url: `${import.meta.env.VITE_OTEL_ENDPOINT}/v1/traces`,
    })
  )
);

provider.register();

registerInstrumentations({
  instrumentations: [
    new FetchInstrumentation({
      ignoreUrls: [/\/health\//],
      propagateTraceHeaderCorsUrls: [
        new RegExp(import.meta.env.VITE_API_URL),
      ],
    }),
    new UserInteractionInstrumentation({
      eventNames: ['click', 'submit'],
    }),
  ],
});
```

---

## Infrastructure Design

### Docker Compose Stack

```yaml
version: '3.8'

services:
  # MongoDB
  mongodb:
    image: mongo:7
    restart: always
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password
    volumes:
      - mongodb-data:/data/db
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh localhost:27017/test --quiet
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis
  redis:
    image: redis:7-alpine
    restart: always
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # OpenObserve
  openobserve:
    image: public.ecr.aws/zinclabs/openobserve:latest
    restart: always
    ports:
      - "5080:5080"
    environment:
      ZO_ROOT_USER_EMAIL: admin@example.com
      ZO_ROOT_USER_PASSWORD: Complexpass#123
      ZO_DATA_DIR: /data
    volumes:
      - openobserve-data:/data
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:5080/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Backend API (3 instances for load balancing)
  backend-1:
    build: ./backend
    restart: always
    environment:
      MONGODB_URI: mongodb://admin:password@mongodb:27017/recipe-book?authSource=admin
      REDIS_URL: redis://redis:6379
      OTEL_EXPORTER_OTLP_ENDPOINT: http://openobserve:5080/api/default
      NODE_ENV: production
    depends_on:
      mongodb:
        condition: service_healthy
      redis:
        condition: service_healthy
      openobserve:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3001/health/ready"]
      interval: 10s
      timeout: 5s
      retries: 3

  backend-2:
    build: ./backend
    restart: always
    environment:
      MONGODB_URI: mongodb://admin:password@mongodb:27017/recipe-book?authSource=admin
      REDIS_URL: redis://redis:6379
      OTEL_EXPORTER_OTLP_ENDPOINT: http://openobserve:5080/api/default
      NODE_ENV: production
    depends_on:
      - backend-1

  backend-3:
    build: ./backend
    restart: always
    environment:
      MONGODB_URI: mongodb://admin:password@mongodb:27017/recipe-book?authSource=admin
      REDIS_URL: redis://redis:6379
      OTEL_EXPORTER_OTLP_ENDPOINT: http://openobserve:5080/api/default
      NODE_ENV: production
    depends_on:
      - backend-2

  # nginx Load Balancer
  nginx:
    image: nginx:alpine
    restart: always
    ports:
      - "3001:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - backend-1
      - backend-2
      - backend-3

  # Frontend
  frontend:
    build: ./frontend
    restart: always
    ports:
      - "5173:80"
    environment:
      VITE_API_URL: http://localhost:3001
      VITE_OTEL_ENDPOINT: http://localhost:5080/api/default
    depends_on:
      - nginx

volumes:
  mongodb-data:
  redis-data:
  openobserve-data:
```

### nginx Load Balancer Configuration

```nginx
# nginx.conf
upstream backend {
    least_conn;  # Use least connections algorithm
    server backend-1:3001 max_fails=3 fail_timeout=30s;
    server backend-2:3001 max_fails=3 fail_timeout=30s;
    server backend-3:3001 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    
    # Health check endpoint bypass
    location /health/ {
        proxy_pass http://backend-1:3001;
    }
    
    # API requests
    location /api/ {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

---

## Security Considerations

### 1. Redis Security
- Use Redis password authentication in production
- Enable TLS for Redis connections (optional)
- Network isolation (Redis not exposed to internet)
- Regular backups of Redis data

### 2. OpenObserve Security
- Change default admin credentials
- Enable authentication for OTLP endpoints
- Use HTTPS in production
- Set up role-based access control

### 3. Logging Security
- Redact sensitive data (passwords, tokens)
- Encrypt log files at rest
- Limit log retention period
- Restrict log file access

### 4. Rate Limiting Security
- Different limits for authenticated vs anonymous
- Stricter limits for sensitive endpoints (auth, password reset)
- IP-based blocking for abuse
- Monitor for rate limit bypass attempts

---

## Performance Optimizations

### Backend Optimizations

1. **Response Compression**
```javascript
const compression = require('compression');
app.use(compression({
  level: 6,
  threshold: 1024, // Only compress responses > 1KB
  filter: (req, res) => {
    if (req.headers['x-no-compression']) return false;
    return compression.filter(req, res);
  },
}));
```

2. **Database Query Optimization**
```javascript
// Use select to limit fields
const recipes = await Recipe.find({ owner: userId })
  .select('title cuisine prepTime')
  .lean(); // Convert to plain JS object

// Use lean for read-only queries
const recipe = await Recipe.findById(id).lean();

// Limit populated fields
const mealPlan = await MealPlan.findById(id)
  .populate('meals.recipe', 'title prepTime cookTime');
```

3. **Caching Strategy**
```javascript
// Cache frequently accessed data
const cacheMiddleware = (duration) => (req, res, next) => {
  const key = `cache:${req.originalUrl}`;
  
  redis.get(key, (err, data) => {
    if (data) {
      return res.json(JSON.parse(data));
    }
    
    res.sendResponse = res.json;
    res.json = (body) => {
      redis.setex(key, duration, JSON.stringify(body));
      res.sendResponse(body);
    };
    next();
  });
};

router.get('/recipes/:id', cacheMiddleware(300), getRecipe);
```

### Frontend Optimizations

1. **Lazy Loading Images**
```javascript
<img 
  loading="lazy"
  src={recipe.imageUrl}
  alt={recipe.title}
/>
```

2. **Debounce Search**
```javascript
import { useMemo } from 'react';
import debounce from 'lodash/debounce';

const debouncedSearch = useMemo(
  () => debounce((query) => fetchRecipes(query), 300),
  []
);
```

3. **Virtual Scrolling (Future)**
```javascript
// Use react-window for large lists
import { FixedSizeList } from 'react-window';
```

---

## Testing Strategy

### 1. Unit Tests
- Redis rate limiter logic
- Logger configuration
- Health check logic
- Database indexes

### 2. Integration Tests
```javascript
describe('Redis Rate Limiting', () => {
  it('should enforce rate limits across instances', async () => {
    const requests = Array.from({ length: 101 }, (_, i) =>
      request(app).get('/api/recipes')
    );
    
    const responses = await Promise.all(requests);
    const rateLimited = responses.filter(r => r.status === 429);
    
    expect(rateLimited.length).toBeGreaterThan(0);
  });
});
```

### 3. Performance Tests
```javascript
// k6 load test script
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // Ramp up
    { duration: '5m', target: 100 }, // Stay at 100
    { duration: '2m', target: 0 },   // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<200'], // 95% under 200ms
  },
};

export default function () {
  const res = http.get('http://localhost:3001/api/recipes');
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 200ms': (r) => r.timings.duration < 200,
  });
  sleep(1);
}
```

---

## Deployment Architecture

### Kubernetes Deployment

```yaml
# k8s/backend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: recipe-book-backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: recipe-book-backend
  template:
    metadata:
      labels:
        app: recipe-book-backend
    spec:
      containers:
      - name: backend
        image: recipe-book-backend:2.1.5
        ports:
        - containerPort: 3001
        env:
        - name: MONGODB_URI
          valueFrom:
            secretKeyRef:
              name: recipe-book-secrets
              key: mongodb-uri
        - name: REDIS_URL
          value: redis://redis-service:6379
        - name: OTEL_EXPORTER_OTLP_ENDPOINT
          value: http://openobserve:5080/api/default
        livenessProbe:
          httpGet:
            path: /health/live
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 3001
          initialDelaySeconds: 10
          periodSeconds: 5
        startupProbe:
          httpGet:
            path: /health/startup
            port: 3001
          failureThreshold: 30
          periodSeconds: 10
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
```

---

## Monitoring & Alerting

### OpenObserve Dashboards

**1. API Performance Dashboard**
- Request rate (requests/sec)
- Response time percentiles (P50, P95, P99)
- Error rate (%)
- Active requests

**2. Database Dashboard**
- Query duration
- Connections (active/idle)
- Slow queries (>100ms)
- Index usage

**3. Redis Dashboard**
- Commands/sec
- Memory usage
- Hit/miss ratio
- Connected clients

**4. Business Metrics Dashboard**
- New users/day
- Recipes created/day
- Active users
- Feature usage

### Alert Rules

```yaml
# Example alert rules (OpenObserve format)
alerts:
  - name: high_error_rate
    condition: error_rate > 5%
    duration: 5m
    severity: critical
    actions:
      - email: dev-team@example.com
      - slack: #alerts
  
  - name: slow_api_response
    condition: p95_duration > 200ms
    duration: 10m
    severity: warning
    actions:
      - slack: #performance
  
  - name: database_connection_errors
    condition: db_errors > 10
    duration: 5m
    severity: critical
    actions:
      - email: ops-team@example.com
```

---

## Rollback Plan

If issues arise after deployment:

1. **Immediate Rollback**
   - Scale down new version
   - Scale up previous version
   - Update load balancer

2. **Partial Rollback**
   - Keep Redis and OpenObserve
   - Rollback application code only
   - Investigation and fix

3. **Data Migration Rollback**
   - Database indexes can stay (no harm)
   - Redis data will naturally expire
   - No breaking schema changes

---

## Next Steps

1. Review and approve this design
2. Set up development environment
3. Begin Phase 3: Implementation
4. Conduct design review meeting

---

**Document Version**: 1.0  
**Last Updated**: February 15, 2026  
**Status**: Ready for review