# V2.2.0 Cloud Backup Integration - Design Document

**Version**: 1.0  
**Status**: Draft  
**Created**: February 16, 2026  
**Last Updated**: February 16, 2026

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Database Design](#database-design)
3. [API Design](#api-design)
4. [OAuth Flow Design](#oauth-flow-design)
5. [Backup System Design](#backup-system-design)
6. [Scheduler Design](#scheduler-design)
7. [Frontend Architecture](#frontend-architecture)
8. [Security Architecture](#security-architecture)
9. [Error Handling Strategy](#error-handling-strategy)
10. [Performance Considerations](#performance-considerations)

---

## Architecture Overview

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────┐
│                      Frontend (React)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ Cloud Backup │  │ OAuth Popup  │  │ Backup       │  │
│  │ Page         │  │ Handler      │  │ History      │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                            │
                    HTTPS / REST API
                            │
┌─────────────────────────────────────────────────────────┐
│                   Backend (Express.js)                   │
│  ┌──────────────────────────────────────────────────┐  │
│  │              Cloud Backup Routes                  │  │
│  │  /api/cloud/dropbox/auth                         │  │
│  │  /api/cloud/google/auth                          │  │
│  │  /api/cloud/backup (POST)                        │  │
│  │  /api/cloud/backups (GET)                        │  │
│  │  /api/cloud/restore (POST)                       │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │            Cloud Backup Controller                │  │
│  │  - OAuth flows                                    │  │
│  │  - Backup creation                                │  │
│  │  - Restore processing                             │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │           Cloud Provider Services                 │  │
│  │  - DropboxService                                 │  │
│  │  - GoogleDriveService                             │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │              Backup Scheduler                     │  │
│  │  - node-cron jobs                                 │  │
│  │  - Automatic backup execution                     │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                            │
                 ┌──────────┴──────────┐
                 │                     │
            MongoDB              Cloud Providers
         (User data,          ┌─────────────────┐
          encrypted tokens)   │ Dropbox API     │
                              │ Google Drive API│
                              └─────────────────┘
```

### Component Responsibilities

**Frontend**:
- OAuth popup management
- Backup trigger UI
- Restore interface
- Progress indicators
- Error display

**Backend**:
- OAuth flow orchestration
- Token management (encryption/decryption)
- Backup file generation
- Cloud upload/download
- Scheduled backup execution
- Provider abstraction layer

**Cloud Providers**:
- File storage
- OAuth authentication
- API rate limiting

---

## Database Design

### User Model Extension

```javascript
// backend/src/models/User.js

const cloudBackupSchema = new mongoose.Schema({
  // Provider Configuration
  provider: {
    type: String,
    enum: ['dropbox', 'google_drive', null],
    default: null
  },
  
  // Encrypted Tokens (using crypto)
  accessToken: {
    type: String,
    select: false  // Never include in queries by default
  },
  refreshToken: {
    type: String,
    select: false
  },
  tokenExpiry: Date,
  
  // Provider Account Info (for display)
  accountEmail: String,
  accountName: String,
  accountId: String,  // Provider-specific user ID
  
  // Backup Schedule Configuration
  schedule: {
    enabled: {
      type: Boolean,
      default: false
    },
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'monthly'],
      default: 'weekly'
    },
    time: {
      type: String,  // HH:mm format (e.g., '02:00')
      default: '02:00'
    },
    timezone: {
      type: String,
      default: 'UTC'
    },
    lastBackup: Date,
    lastBackupStatus: {
      type: String,
      enum: ['success', 'failed', 'in_progress'],
      default: null
    },
    nextBackup: Date,
    failureCount: {
      type: Number,
      default: 0
    }
  },
  
  // Retention Policy
  retention: {
    maxBackups: {
      type: Number,
      default: 10,
      min: 1,
      max: 100
    },
    autoCleanup: {
      type: Boolean,
      default: true
    }
  },
  
  // Statistics
  stats: {
    totalBackups: {
      type: Number,
      default: 0
    },
    manualBackups: {
      type: Number,
      default: 0
    },
    autoBackups: {
      type: Number,
      default: 0
    },
    lastManualBackup: Date,
    totalStorageUsed: {
      type: Number,  // in bytes
      default: 0
    }
  }
}, { _id: false });

// Add to User schema
const userSchema = new mongoose.Schema({
  // ... existing fields ...
  
  cloudBackup: cloudBackupSchema
  
  // ... rest of schema ...
});
```

### Backup History Model (Optional - In-Memory Cache)

For listing recent backups, we'll query the cloud provider directly rather than maintaining a separate database table. This ensures sync with actual cloud state.

**Rationale**: Cloud provider is source of truth for backup files

---

## API Design

### Endpoint Summary

```javascript
// Dropbox OAuth
GET    /api/cloud/dropbox/auth          - Initiate Dropbox OAuth
GET    /api/cloud/dropbox/callback      - Handle OAuth callback

// Google Drive OAuth  
GET    /api/cloud/google/auth           - Initiate Google OAuth
GET    /api/cloud/google/callback       - Handle OAuth callback

// Provider Management
GET    /api/cloud/status                - Get connection status
POST   /api/cloud/disconnect            - Disconnect provider

// Backup Operations
POST   /api/cloud/backup                - Create manual backup
GET    /api/cloud/backups               - List available backups
DELETE /api/cloud/backups/:id           - Delete specific backup

// Restore Operations
POST   /api/cloud/restore               - Restore from backup
POST   /api/cloud/restore/preview       - Preview backup contents

// Schedule Management
PUT    /api/cloud/schedule              - Update backup schedule
GET    /api/cloud/schedule              - Get current schedule
```

### Detailed Endpoint Specifications

#### 1. Initiate Dropbox OAuth

```javascript
/**
 * GET /api/cloud/dropbox/auth
 * 
 * Initiates Dropbox OAuth flow
 * 
 * Auth: Required (JWT)
 * Rate Limit: 10 per hour
 */
router.get('/dropbox/auth', authenticate, async (req, res) => {
  try {
    // Generate CSRF state token
    const state = crypto.randomBytes(16).toString('hex');
    
    // Store state in session/cache (Redis)
    await redis.setex(`oauth:state:${state}`, 600, req.user._id);
    
    // Build OAuth URL
    const authUrl = `https://www.dropbox.com/oauth2/authorize?` +
      `client_id=${process.env.DROPBOX_CLIENT_ID}&` +
      `response_type=code&` +
      `redirect_uri=${encodeURIComponent(process.env.DROPBOX_REDIRECT_URI)}&` +
      `state=${state}&` +
      `token_access_type=offline`;  // Request refresh token
    
    res.json({ success: true, authUrl, state });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Failed to initiate OAuth' });
  }
});
```

**Response**:
```json
{
  "success": true,
  "authUrl": "https://www.dropbox.com/oauth2/authorize?...",
  "state": "abc123..."
}
```

#### 2. Dropbox OAuth Callback

```javascript
/**
 * GET /api/cloud/dropbox/callback
 * 
 * Handles Dropbox OAuth callback
 * 
 * Query params: code, state
 */
router.get('/dropbox/callback', async (req, res) => {
  try {
    const { code, state } = req.query;
    
    // Validate state token
    const userId = await redis.get(`oauth:state:${state}`);
    if (!userId) {
      throw new Error('Invalid or expired state token');
    }
    
    // Exchange code for tokens
    const tokenResponse = await axios.post(
      'https://api.dropboxapi.com/oauth2/token',
      new URLSearchParams({
        code,
        grant_type: 'authorization_code',
        client_id: process.env.DROPBOX_CLIENT_ID,
        client_secret: process.env.DROPBOX_CLIENT_SECRET,
        redirect_uri: process.env.DROPBOX_REDIRECT_URI
      })
    );
    
    const { access_token, refresh_token, expires_in } = tokenResponse.data;
    
    // Get account info
    const accountInfo = await getDropboxAccountInfo(access_token);
    
    // Encrypt and store tokens
    const user = await User.findById(userId);
    user.cloudBackup = {
      provider: 'dropbox',
      accessToken: encryptToken(access_token),
      refreshToken: encryptToken(refresh_token),
      tokenExpiry: new Date(Date.now() + expires_in * 1000),
      accountEmail: accountInfo.email,
      accountName: accountInfo.name.display_name,
      accountId: accountInfo.account_id
    };
    
    await user.save();
    
    // Redirect to success page
    res.redirect('/account/cloud-backup?success=true');
  } catch (error) {
    res.redirect('/account/cloud-backup?error=oauth_failed');
  }
});
```

#### 3. Create Manual Backup

```javascript
/**
 * POST /api/cloud/backup
 * 
 * Creates and uploads backup to cloud provider
 * 
 * Auth: Required
 * Rate Limit: 10 per hour
 */
router.post('/backup', authenticate, cloudBackupLimiter, async (req, res) => {
  try {
    const user = await User.findById(req.user._id)
      .select('+cloudBackup.accessToken +cloudBackup.refreshToken');
    
    if (!user.cloudBackup || !user.cloudBackup.provider) {
      return res.status(400).json({
        success: false,
        message: 'No cloud provider connected'
      });
    }
    
    // Generate backup file
    const backupPath = await generateBackupFile(user._id);
    
    // Upload to cloud provider
    let uploadResult;
    if (user.cloudBackup.provider === 'dropbox') {
      uploadResult = await uploadToDropbox(user, backupPath);
    } else {
      uploadResult = await uploadToGoogleDrive(user, backupPath);
    }
    
    // Update stats
    user.cloudBackup.stats.totalBackups++;
    user.cloudBackup.stats.manualBackups++;
    user.cloudBackup.stats.lastManualBackup = new Date();
    user.cloudBackup.schedule.lastBackup = new Date();
    user.cloudBackup.schedule.lastBackupStatus = 'success';
    await user.save();
    
    // Clean up local file
    fs.unlinkSync(backupPath);
    
    res.json({
      success: true,
      backup: {
        id: uploadResult.id,
        filename: uploadResult.name,
        size: uploadResult.size,
        timestamp: new Date(),
        type: 'manual'
      }
    });
  } catch (error) {
    logger.error('Backup failed:', error);
    res.status(500).json({
      success: false,
      message: 'Backup failed. Please try again.'
    });
  }
});
```

**Response**:
```json
{
  "success": true,
  "backup": {
    "id": "id:abc123",
    "filename": "recipe-book-backup-2026-02-16-140500.zip",
    "size": 1048576,
    "timestamp": "2026-02-16T14:05:00Z",
    "type": "manual"
  }
}
```

#### 4. List Backups

```javascript
/**
 * GET /api/cloud/backups
 * 
 * Lists available backups from cloud provider
 * 
 * Query params: limit (default: 10)
 */
router.get('/backups', authenticate, async (req, res) => {
  try {
    const { limit = 10 } = req.query;
    
    const user = await User.findById(req.user._id)
      .select('+cloudBackup.accessToken +cloudBackup.refreshToken');
    
    if (!user.cloudBackup || !user.cloudBackup.provider) {
      return res.json({
        success: true,
        backups: [],
        total: 0
      });
    }
    
    // List files from cloud provider
    let backups;
    if (user.cloudBackup.provider === 'dropbox') {
      backups = await listDropboxBackups(user, limit);
    } else {
      backups = await listGoogleDriveBackups(user, limit);
    }
    
    res.json({
      success: true,
      backups,
      total: backups.length
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to list backups'
    });
  }
});
```

**Response**:
```json
{
  "success": true,
  "backups": [
    {
      "id": "id:abc123",
      "filename": "recipe-book-backup-2026-02-16-140500.zip",
      "size": 1048576,
      "timestamp": "2026-02-16T14:05:00Z",
      "type": "manual"
    }
  ],
  "total": 1
}
```

#### 5. Restore from Backup

```javascript
/**
 * POST /api/cloud/restore
 * 
 * Downloads and restores backup from cloud
 * 
 * Body: { backupId, mode: 'merge'|'replace', password }
 */
router.post('/restore', authenticate, cloudBackupLimiter, async (req, res) => {
  try {
    const { backupId, mode, password } = req.body;
    
    // Validate password
    const user = await User.findById(req.user._id).select('+password');
    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
      return res.status(401).json({
        success: false,
        message: 'Invalid password'
      });
    }
    
    // Download backup from cloud
    const backupPath = await downloadBackup(user, backupId);
    
    // Process import (reuse import logic from REQ-016)
    const statistics = await processBackupImport(
      user._id,
      backupPath,
      mode
    );
    
    // Clean up
    fs.unlinkSync(backupPath);
    
    res.json({
      success: true,
      statistics
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Restore failed. Please try again.'
    });
  }
});
```

---

## OAuth Flow Design

### Dropbox OAuth Flow

```
┌─────────┐                                    ┌──────────┐
│ Frontend│                                    │  Backend │
└────┬────┘                                    └────┬─────┘
     │                                              │
     │ 1. Click "Connect Dropbox"                   │
     │─────────────────────────────────────────────>│
     │                                              │
     │           2. GET /api/cloud/dropbox/auth     │
     │<─────────────────────────────────────────────│
     │           (authUrl, state)                   │
     │                                              │
     │ 3. Open popup window                         │
     │    with authUrl                              │
     │                                              │
┌────▼────┐                            ┌──────────▼──────┐
│ Dropbox │                            │ State stored in │
│  OAuth  │                            │  Redis (10 min) │
│  Page   │                            └─────────────────┘
└────┬────┘
     │
     │ 4. User authorizes
     │
     │ 5. Redirect to callback URL
     │    with code & state
     │
┌────▼────┐
│ Backend │
│ Callback│
└────┬────┘
     │
     │ 6. Validate state from Redis
     │ 7. Exchange code for tokens
     │ 8. Get account info
     │ 9. Encrypt & store tokens
     │ 10. Redirect to success page
     │
┌────▼────┐
│ Success │
│  Page   │
└─────────┘
```

### Token Refresh Flow

```javascript
/**
 * Automatic token refresh when expired
 */
async function ensureValidToken(user) {
  // Check if token is expired
  if (user.cloudBackup.tokenExpiry > new Date()) {
    return decryptToken(user.cloudBackup.accessToken);
  }
  
  // Refresh token
  const refreshToken = decryptToken(user.cloudBackup.refreshToken);
  
  if (user.cloudBackup.provider === 'dropbox') {
    const response = await axios.post(
      'https://api.dropboxapi.com/oauth2/token',
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: process.env.DROPBOX_CLIENT_ID,
        client_secret: process.env.DROPBOX_CLIENT_SECRET
      })
    );
    
    // Update stored token
    user.cloudBackup.accessToken = encryptToken(response.data.access_token);
    user.cloudBackup.tokenExpiry = new Date(Date.now() + response.data.expires_in * 1000);
    await user.save();
    
    return response.data.access_token;
  }
  
  // Similar logic for Google Drive
}
```

---

## Backup System Design

### Backup File Generation

```javascript
/**
 * Generates backup file (reuses export logic from V2.0)
 */
async function generateBackupFile(userId) {
  // Fetch all user data
  const [recipes, collections, mealPlans, shoppingLists] = await Promise.all([
    Recipe.find({ owner: userId }),
    Collection.find({ owner: userId }),
    MealPlan.find({ owner: userId }),
    ShoppingList.find({ owner: userId })
  ]);
  
  // Create backup JSON
  const backupData = {
    version: '2.2.0',
    exportDate: new Date().toISOString(),
    recipes: recipes.map(cleanDocument),
    collections: collections.map(cleanDocument),
    mealPlans: mealPlans.map(cleanDocument),
    shoppingLists: shoppingLists.map(cleanDocument)
  };
  
  // Write to temp file
  const tempDir = path.join(__dirname, '../../temp');
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true });
  }
  
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const jsonPath = path.join(tempDir, `backup-${userId}-${timestamp}.json`);
  const zipPath = path.join(tempDir, `backup-${userId}-${timestamp}.zip`);
  
  fs.writeFileSync(jsonPath, JSON.stringify(backupData, null, 2));
  
  // Compress to zip
  await compressFile(jsonPath, zipPath);
  
  // Clean up JSON
  fs.unlinkSync(jsonPath);
  
  return zipPath;
}

/**
 * Compress file to zip
 */
async function compressFile(inputPath, outputPath) {
  return new Promise((resolve, reject) => {
    const output = fs.createWriteStream(outputPath);
    const archive = archiver('zip', { zlib: { level: 9 } });
    
    output.on('close', () => resolve(outputPath));
    archive.on('error', reject);
    
    archive.pipe(output);
    archive.file(inputPath, { name: 'backup.json' });
    archive.finalize();
  });
}
```

### Cloud Upload Implementation

```javascript
// backend/src/services/cloudProviders/dropbox.js

const { Dropbox } = require('dropbox');

class DropboxService {
  /**
   * Upload backup file to Dropbox
   */
  async uploadBackup(user, localFilePath) {
    const accessToken = await ensureValidToken(user);
    const dbx = new Dropbox({ accessToken });
    
    const fileContent = fs.readFileSync(localFilePath);
    const timestamp = new Date().toISOString().replace(/[:.]/g, '');
    const filename = `recipe-book-backup-${timestamp}.zip`;
    const path = `/Apps/Recipe Book/${filename}`;
    
    const response = await dbx.filesUpload({
      path,
      contents: fileContent,
      mode: 'add',
      autorename: true
    });
    
    return {
      id: response.result.id,
      name: response.result.name,
      size: response.result.size,
      path: response.result.path_display
    };
  }
  
  /**
   * List backups from  Dropbox
   */
  async listBackups(user, limit = 10) {
    const accessToken = await ensureValidToken(user);
    const dbx = new Dropbox({ accessToken });
    
    const response = await dbx.filesListFolder({
      path: '/Apps/Recipe Book',
      limit
    });
    
    return response.result.entries
      .filter(entry => entry.name.endsWith('.zip'))
      .sort((a, b) => new Date(b.client_modified) - new Date(a.client_modified))
      .map(entry => ({
        id: entry.id,
        filename: entry.name,
        size: entry.size,
        timestamp: entry.client_modified,
        type: entry.name.includes('auto') ? 'automatic' : 'manual'
      }));
  }
  
  /**
   * Download backup from Dropbox
   */
  async downloadBackup(user, fileId) {
    const accessToken = await ensureValidToken(user);
    const dbx = new Dropbox({ accessToken });
    
    const response = await dbx.filesDownload({ path: fileId });
    
    const tempDir = path.join(__dirname, '../../../temp');
    const tempPath = path.join(tempDir, `download-${Date.now()}.zip`);
    
    fs.writeFileSync(tempPath, response.result.fileBinary);
    
    return tempPath;
  }
  
  /**
   * Delete backup from Dropbox
   */
  async deleteBackup(user, fileId) {
    const accessToken = await ensureValidToken(user);
    const dbx = new Dropbox({ accessToken });
    
    await dbx.filesDeleteV2({ path: fileId });
  }
}

module.exports = new DropboxService();
```

---

## Scheduler Design

### node-cron Implementation

```javascript
// backend/src/services/backupScheduler.js

const cron = require('node-cron');
const User = require('../models/User');
const { generateBackupFile, uploadBackup } = require('./cloudBackup');

class BackupScheduler {
  constructor() {
    this.jobs = new Map();
  }
  
  /**
   * Initialize scheduler - check every hour
   */
  start() {
    // Run every hour at minute 5
    cron.schedule('5 * * * *', async () => {
      await this.checkAndExecuteBackups();
    });
    
    logger.info('Backup scheduler started');
  }
  
  /**
   * Check for due backups and execute
   */
  async checkAndExecuteBackups() {
    try {
      const now = new Date();
      
      // Find users with due backups
      const users = await User.find({
        'cloudBackup.schedule.enabled': true,
        'cloudBackup.schedule.nextBackup': { $lte: now }
      }).select('+cloudBackup.accessToken +cloudBackup.refreshToken');
      
      logger.info(`Found ${users.length} due backups`);
      
      // Execute backups in parallel (with concurrency limit)
      const results = await Promise.allSettled(
        users.map(user => this.executeBackup(user))
      );
      
      // Log results
      const successful = results.filter(r => r.status === 'fulfilled').length;
      const failed = results.filter(r => r.status === 'rejected').length;
      logger.info(`Backups executed: ${successful} successful, ${failed} failed`);
      
    } catch (error) {
      logger.error('Backup scheduler error:', error);
    }
  }
  
  /**
   * Execute backup for a user
   */
  async executeBackup(user) {
    try {
      // Update status to in_progress
      user.cloudBackup.schedule.lastBackupStatus = 'in_progress';
      await user.save();
      
      // Generate and upload backup
      const backupPath = await generateBackupFile(user._id);
      await uploadBackup(user, backupPath);
      
      // Clean up old backups if retention policy enabled
      if (user.cloudBackup.retention.autoCleanup) {
        await this.cleanupOldBackups(user);
      }
      
      // Update user record
      user.cloudBackup.schedule.lastBackup = new Date();
      user.cloudBackup.schedule.lastBackupStatus = 'success';
      user.cloudBackup.schedule.failureCount = 0;
      user.cloudBackup.schedule.nextBackup = this.calculateNextBackup(user);
      user.cloudBackup.stats.totalBackups++;
      user.cloudBackup.stats.autoBackups++;
      
      await user.save();
      
      logger.info(`Backup successful for user ${user._id}`);
      
    } catch (error) {
      logger.error(`Backup failed for user ${user._id}:`, error);
      
      // Update failure count
      user.cloudBackup.schedule.lastBackupStatus = 'failed';
      user.cloudBackup.schedule.failureCount++;
      
      // Retry in 1 hour if failures < 3
      if (user.cloudBackup.schedule.failureCount < 3) {
        user.cloudBackup.schedule.nextBackup = new Date(Date.now() + 60 * 60 * 1000);
      } else {
        // Disable after 3 failures
        user.cloudBackup.schedule.enabled = false;
        // TODO: Send email notification
      }
      
      await user.save();
      
      throw error;
    }
  }
  
  /**
   * Calculate next backup time
   */
  calculateNextBackup(user) {
    const { frequency, time } = user.cloudBackup.schedule;
    const [hours, minutes] = time.split(':').map(Number);
    
    let next = new Date();
    next.setHours(hours, minutes, 0, 0);
    
    // If time has passed today, move to next occurrence
    if (next <= new Date()) {
      if (frequency === 'daily') {
        next.setDate(next.getDate() + 1);
      } else if (frequency === 'weekly') {
        next.setDate(next.getDate() + 7);
      } else if (frequency === 'monthly') {
        next.setMonth(next.getMonth() + 1);
      }
    }
    
    return next;
  }
  
  /**
   * Clean up old backups based on retention policy
   */
  async cleanupOldBackups(user) {
    const maxBackups = user.cloudBackup.retention.maxBackups;
    const backups = await listBackups(user, 100);
    
    if (backups.length > maxBackups) {
      const toDelete = backups.slice(maxBackups);
      await Promise.all(
        toDelete.map(backup => deleteBackup(user, backup.id))
      );
      logger.info(`Cleaned up ${toDelete.length} old backups for user ${user._id}`);
    }
  }
}

module.exports = new BackupScheduler();
```

---

## Frontend Architecture

### Component Structure

```
frontend/src/components/
├── auth/
│   ├── AccountSettingsPage.jsx      # Add cloud backup section
│   └── CloudBackupPage.jsx          # New: Full cloud backup UI
├── cloud/
│   ├── OAuthPopup.jsx               # OAuth popup handler
│   ├── BackupHistoryTable.jsx      # Backup list display
│   ├── RestoreModal.jsx             # Restore confirmation
│   └── ScheduleConfigForm.jsx      # Backup schedule config
```

### CloudBackupPage Component

```jsx
// frontend/src/components/auth/CloudBackupPage.jsx

import React, { useState, useEffect } from 'react';
import { cloudAPI } from '../../services/api';

export default function CloudBackupPage() {
  const [status, setStatus] = useState(null);
  const [backups, setBackups] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchStatus();
    fetchBackups();
  }, []);
  
  const fetchStatus = async () => {
    const response = await cloudAPI.getStatus();
    setStatus(response.data);
  };
  
  const fetchBackups = async () => {
    const response = await cloudAPI.listBackups();
    setBackups(response.data.backups);
    setLoading(false);
  };
  
  const handleConnectDropbox = async () => {
    const response = await cloudAPI.initiateDropboxAuth();
    const popup = window.open(
      response.data.authUrl,
      'Dropbox Authorization',
      'width=600,height=700'
    );
    
    // Poll for popup close
    const interval = setInterval(() => {
      if (popup.closed) {
        clearInterval(interval);
        fetchStatus();
        fetchBackups();
      }
    }, 500);
  };
  
  const handleBackupNow = async () => {
    setLoading(true);
    try {
      await cloudAPI.createBackup();
      fetchBackups();
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-4xl font-display font-bold text-cookbook-darkbrown mb-8">
        Cloud Backup
      </h1>
      
      {/* Provider Connection Section */}
      <div className="bg-cookbook-paper border-2 border-cookbook-aged rounded-lg shadow-card p-6 mb-6">
        <h2 className="text-2xl font-display font-bold text-cookbook-darkbrown mb-4">
          Provider Connection
        </h2>
        
        {!status?.provider ? (
          <div>
            <p className="text-cookbook-accent mb-4">
              Connect your cloud storage to enable automatic backups
            </p>
            <div className="flex gap-4">
              <button
                onClick={handleConnectDropbox}
                className="px-6 py-3 bg-cookbook-accent text-white font-body rounded-lg hover:bg-cookbook-darkbrown transition-colors"
              >
                Connect Dropbox
              </button>
              <button
                onClick={handleConnectGoogle}
                className="px-6 py-3 bg-cookbook-accent text-white font-body rounded-lg hover:bg-cookbook-darkbrown transition-colors"
              >
                Connect Google Drive
              </button>
            </div>
          </div>
        ) : (
          <div>
            <div className="flex items-center gap-3 mb-4">
              <span className="text-green-600">✓</span>
              <span className="font-body text-cookbook-darkbrown">
                Connected to {status.provider === 'dropbox' ? 'Dropbox' : 'Google Drive'}
              </span>
            </div>
            <p className="text-cookbook-accent mb-4">
              Account: {status.accountEmail}
            </p>
            <button
              onClick={handleDisconnect}
              className="px-4 py-2 border-2 border-cookbook-aged text-cookbook-darkbrown font-body rounded-lg hover:bg-cookbook-cream transition-colors"
            >
              Disconnect
            </button>
          </div>
        )}
      </div>
      
      {/* Backup Schedule Section */}
      {status?.provider && (
        <div className="bg-cookbook-paper border-2 border-cookbook-aged rounded-lg shadow-card p-6 mb-6">
          <h2 className="text-2xl font-display font-bold text-cookbook-darkbrown mb-4">
            Backup Schedule
          </h2>
          <ScheduleConfigForm schedule={status.schedule} onUpdate={fetchStatus} />
          <button
            onClick={handleBackupNow}
            disabled={loading}
            className="mt-4 px-6 py-3 bg-cookbook-accent text-white font-body rounded-lg hover:bg-cookbook-darkbrown transition-colors disabled:opacity-50"
          >
            {loading ? 'Backing up...' : 'Backup Now'}
          </button>
        </div>
      )}
      
      {/* Backup History Section */}
      {status?.provider && (
        <div className="bg-cookbook-paper border-2 border-cookbook-aged rounded-lg shadow-card p-6">
          <h2 className="text-2xl font-display font-bold text-cookbook-darkbrown mb-4">
            Backup History
          </h2>
          <BackupHistoryTable backups={backups} onRefresh={fetchBackups} />
        </div>
      )}
    </div>
  );
}
```

---

## Security Architecture

### Token Encryption

```javascript
// backend/src/utils/encryption.js

const crypto = require('crypto');

const ALGORITHM = 'aes-256-cbc';
const ENCRYPTION_KEY = process.env.CLOUD_TOKEN_ENCRYPTION_KEY; // Must be 32 bytes
const IV_LENGTH = 16;

/**
 * Encrypt token before storing in database
 */
function encryptToken(token) {
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(
    ALGORITHM,
    Buffer.from(ENCRYPTION_KEY, 'hex'),
    iv
  );
  
  let encrypted = cipher.update(token, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  // Return IV + encrypted data
  return iv.toString('hex') + ':' + encrypted;
}

/**
 * Decrypt token when needed
 */
function decryptToken(encryptedToken) {
  const [ivHex, encrypted] = encryptedToken.split(':');
  const iv = Buffer.from(ivHex, 'hex');
  
  const decipher = crypto.createDecipheriv(
    ALGORITHM,
    Buffer.from(ENCRYPTION_KEY, 'hex'),
    iv
  );
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

module.exports = { encryptToken, decryptToken };
```

### Rate Limiting

```javascript
// Apply to all cloud endpoints
const cloudBackupLimiter = createRateLimiter({
  windowMs: 60 * 60 * 1000,  // 1 hour
  max: 10,                    // 10 requests per hour
  message: 'Too many backup operations. Please try again later.'
});

router.use('/cloud', cloudBackupLimiter);
```

---

## Error Handling Strategy

### Error Types & Responses

```javascript
// Standardized error responses

class CloudBackupError extends Error {
  constructor(type, message, details = {}) {
    super(message);
    this.type = type;
    this.details = details;
  }
}

// Error types:
// - OAUTH_FAILED: OAuth authorization failed
// - TOKEN_EXPIRED: Access token expired, refresh failed
// - QUOTA_EXCEEDED: Cloud storage quota exceeded
// - NETWORK_ERROR: Network connection issue
// - BACKUP_FAILED: Backup creation/upload failed
// - RESTORE_FAILED: Restore/download failed
// - INVALID_BACKUP: Backup file corrupted or invalid

// Error handler middleware
function cloudErrorHandler(err, req, res, next) {
  if (err instanceof CloudBackupError) {
    const statusCode = getStatusCode(err.type);
    return res.status(statusCode).json({
      success: false,
      error: err.type,
      message: err.message,
      details: err.details
    });
  }
  next(err);
}

function getStatusCode(errorType) {
  const codes = {
    OAUTH_FAILED: 401,
    TOKEN_EXPIRED: 401,
    QUOTA_EXCEEDED: 507,
    NETWORK_ERROR: 503,
    BACKUP_FAILED: 500,
    RESTORE_FAILED: 500,
    INVALID_BACKUP: 400
  };
  return codes[errorType] || 500;
}
```

---

## Performance Considerations

### Optimization Strategies

1. **Parallel Processing**
   - Upload backup file while generating next
   - List backups concurrently with status check
   - Use Promise.all for independent operations

2. **Compression**
   - Use level 9 compression for backups
   - Target 70%+ size reduction
   - Stream large files instead of loading into memory

3. **Caching**
   - Cache OAuth state tokens in Redis (10 min)
   - Cache backup list for 5 minutes
   - Invalidate cache on backup/delete

4. **Background Jobs**
   - Run scheduled backups asynchronously
   - Queue backup operations (future: Bull queue)
   - Monitor job execution time

5. **Database Queries**
   - Index on cloudBackup.schedule.nextBackup
   - Select only needed fields (+accessToken, +refreshToken when required)
   - Use lean() for read-only queries

---

## Next Steps

1. **Implementation Order**:
   - Week 1: OAuth flows + token management
   - Week 2: Manual backup + Dropbox upload
   - Week 3: Restore functionality
   - Week 4: Automatic backups + scheduler
   - Week 5: Google Drive integration
   - Week 6: UI polish + testing
   - Week 7-8: Code review + production deployment

2. **Testing Strategy**:
   - Unit tests for encryption/decryption
   - Integration tests for OAuth flows
   - Integration tests for backup/restore
   - E2E tests with real cloud accounts (sandbox)
   - Load testing for concurrent backups

3. **Documentation**:
   - API documentation updates
   - User guide for cloud backup setup
   - Troubleshooting guide
   - Admin guide for monitoring

---

**Document Version**: 1.0  
**Author**: Development Team  
**Status**: Ready for Implementation  
**Next Review**: After Week 2 Implementation