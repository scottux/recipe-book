# V2.3.0 Design & Architecture

**Version**: 2.3.0  
**Phase**: Design & Architecture (Phase 3 of SDLC)  
**Date**: February 17, 2026  
**Status**: Complete

---

## Overview

This document outlines the design and architecture for V2.3.0 technical debt and test infrastructure improvements. The design focuses on creating robust test helpers, fixing failing tests, and updating dependencies without introducing breaking changes.

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Test Infrastructure Design](#test-infrastructure-design)
3. [Authentication Helper Design](#authentication-helper-design)
4. [Dependency Update Strategy](#dependency-update-strategy)
5. [Code Quality Improvements](#code-quality-improvements)
6. [Developer Experience Enhancements](#developer-experience-enhancements)

---

## Architecture Overview

### High-Level Design

```
┌─────────────────────────────────────────────────────────────┐
│                     V2.3.0 Improvements                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────┐      ┌──────────────────┐            │
│  │ Test            │      │ Dependency       │            │
│  │ Infrastructure  │      │ Updates          │            │
│  │                 │      │                  │            │
│  │ • Auth Helpers  │      │ • nodemailer     │            │
│  │ • Test Patterns │      │ • happy-dom      │            │
│  │ • CI/CD Updates │      │ • Security Fixes │            │
│  └─────────────────┘      └──────────────────┘            │
│                                                             │
│  ┌─────────────────┐      ┌──────────────────┐            │
│  │ Code Quality    │      │ Developer        │            │
│  │ Improvements    │      │ Experience       │            │
│  │                 │      │                  │            │
│  │ • Mongoose Fix  │      │ • Pre-commit     │            │
│  │ • Error Handler │      │ • Documentation  │            │
│  │ • Code Cleanup  │      │ • Tooling        │            │
│  └─────────────────┘      └──────────────────┘            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Design Principles

1. **Backwards Compatibility**: No breaking changes to production code
2. **Test Isolation**: Each test independent and deterministic
3. **Developer Experience**: Simple, clear, well-documented
4. **Security First**: Address all high/critical vulnerabilities
5. **Maintainability**: Clean, consistent patterns

---

## Test Infrastructure Design

### Current Problems

```javascript
// ❌ PROBLEM: Shared authentication state
let token = '';
beforeAll(async () => {
  token = jwt.sign({ userId: user._id }, JWT_SECRET);
});

// Tests share same token, causing:
// - Token expiration affecting multiple tests
// - User state conflicts
// - Race conditions
```

### Proposed Solution

```javascript
// ✅ SOLUTION: Isolated authentication per test
test('should create recipe', async () => {
  const { user, token } = await createAuthenticatedUser();
  
  const response = await request(app)
    .post('/api/recipes')
    .set('Authorization', `Bearer ${token}`)
    .send(recipeData);
  
  expect(response.status).toBe(201);
});
```

### Architecture Components

```
┌──────────────────────────────────────────────────────┐
│             Test Infrastructure                      │
├──────────────────────────────────────────────────────┤
│                                                      │
│  ┌────────────────────────────────────────────┐    │
│  │        Test Helper Layer                   │    │
│  │                                            │    │
│  │  authHelpers.js                           │    │
│  │  • createAuthenticatedUser()              │    │
│  │  • generateAuthToken()                    │    │
│  │  • getAuthHeaders()                       │    │
│  │  • cleanupTestUsers()                     │    │
│  │                                            │    │
│  │  testDataFactories.js                     │    │
│  │  • createTestRecipe()                     │    │
│  │  • createTestCollection()                 │    │
│  │  • createTestMealPlan()                   │    │
│  │                                            │    │
│  │  requestHelpers.js                        │    │
│  │  • makeAuthenticatedRequest()             │    │
│  │  • expectSuccess()                        │    │
│  │  • expectError()                          │    │
│  └────────────────────────────────────────────┘    │
│                        ↓                            │
│  ┌────────────────────────────────────────────┐    │
│  │        Test Execution Layer                │    │
│  │                                            │    │
│  │  Integration Tests                        │    │
│  │  • account-management.test.js             │    │
│  │  • cloud-backup.test.js                   │    │
│  │  • collections.test.js                    │    │
│  │  • etc...                                 │    │
│  └────────────────────────────────────────────┘    │
│                        ↓                            │
│  ┌────────────────────────────────────────────┐    │
│  │        Test Setup Layer                    │    │
│  │                                            │    │
│  │  globalSetup.js                           │    │
│  │  • Start MongoDB Memory Server            │    │
│  │  • Initialize test environment            │    │
│  │                                            │    │
│  │  globalTeardown.js                        │    │
│  │  • Stop MongoDB Memory Server             │    │
│  │  • Cleanup resources                      │    │
│  └────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────┘
```

---

## Authentication Helper Design

### Design Goals

1. **Unique Per Test**: Each test gets isolated auth state
2. **Simple API**: Easy to use, minimal boilerplate
3. **Flexible**: Support different user configurations
4. **Clean**: Automatic cleanup of test data
5. **Fast**: Minimal overhead per test

### Helper Architecture

```javascript
// backend/src/__tests__/helpers/authHelpers.js

/**
 * Authentication Helper Module
 * 
 * Provides utilities for creating authenticated test users
 * and managing authentication state in integration tests.
 */

// ============================================
// Core Functions
// ============================================

/**
 * Create an authenticated test user with JWT token
 * 
 * @param {Object} userData - User data override
 * @param {string} userData.username - Unique username (auto-generated if not provided)
 * @param {string} userData.email - Unique email (auto-generated if not provided)
 * @param {string} userData.password - Password (default: 'Test123!')
 * @param {boolean} userData.emailVerified - Email verified status (default: true)
 * @param {boolean} userData.twoFactorEnabled - 2FA status (default: false)
 * @returns {Promise<{user: Object, token: string}>}
 * 
 * @example
 * const { user, token } = await createAuthenticatedUser();
 * const headers = getAuthHeaders(token);
 */
async function createAuthenticatedUser(userData = {}) {
  // Generate unique identifiers
  const timestamp = Date.now();
  const randomSuffix = Math.random().toString(36).substring(7);
  
  const defaultUser = {
    username: `test_${timestamp}_${randomSuffix}`,
    email: `test_${timestamp}_${randomSuffix}@example.com`,
    password: 'Test123!',
    emailVerified: true,
    twoFactorEnabled: false,
    testUser: true // Marker for cleanup
  };
  
  const finalUserData = { ...defaultUser, ...userData };
  
  // Hash password
  const hashedPassword = await bcrypt.hash(finalUserData.password, 10);
  
  // Create user
  const user = await User.create({
    ...finalUserData,
    password: hashedPassword
  });
  
  // Generate JWT token (1 hour expiration for tests)
  const token = jwt.sign(
    { userId: user._id },
    process.env.JWT_SECRET,
    { expiresIn: '1h' }
  );
  
  // Track for cleanup
  testUsers.push(user._id);
  
  return {
    user: user.toObject(),
    token
  };
}

/**
 * Get authorization headers for authenticated requests
 * 
 * @param {string} token - JWT token
 * @returns {Object} Headers object
 * 
 * @example
 * const headers = getAuthHeaders(token);
 * const response = await request(app)
 *   .get('/api/recipes')
 *   .set(headers);
 */
function getAuthHeaders(token) {
  return {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  };
}

/**
 * Clean up all test users created during test run
 * 
 * @returns {Promise<void>}
 * 
 * @example
 * afterEach(async () => {
 *   await cleanupTestUsers();
 * });
 */
async function cleanupTestUsers() {
  if (testUsers.length === 0) return;
  
  await User.deleteMany({ _id: { $in: testUsers } });
  testUsers = [];
}

/**
 * Create multiple authenticated test users
 * 
 * @param {number} count - Number of users to create
 * @returns {Promise<Array<{user: Object, token: string}>>}
 * 
 * @example
 * const users = await createMultipleUsers(3);
 * const [user1, user2, user3] = users;
 */
async function createMultipleUsers(count) {
  const users = [];
  for (let i = 0; i < count; i++) {
    const { user, token } = await createAuthenticatedUser();
    users.push({ user, token });
  }
  return users;
}

/**
 * Verify JWT token is valid
 * 
 * @param {string} token - JWT token to verify
 * @returns {Promise<Object>} Decoded token payload
 * @throws {Error} If token is invalid
 * 
 * @example
 * const payload = await verifyToken(token);
 * expect(payload.userId).toBeDefined();
 */
async function verifyToken(token) {
  return jwt.verify(token, process.env.JWT_SECRET);
}

// ============================================
// Export
// ============================================

module.exports = {
  createAuthenticatedUser,
  getAuthHeaders,
  cleanupTestUsers,
  createMultipleUsers,
  verifyToken
};
```

### Usage Patterns

#### Pattern 1: Simple Authentication

```javascript
test('should create recipe', async () => {
  // Setup: Create authenticated user
  const { user, token } = await createAuthenticatedUser();
  
  // Execute: Make authenticated request
  const response = await request(app)
    .post('/api/recipes')
    .set('Authorization', `Bearer ${token}`)
    .send(recipeData);
  
  // Verify
  expect(response.status).toBe(201);
  expect(response.body.owner).toBe(user._id.toString());
  
  // Cleanup (in afterEach)
  // await cleanupTestUsers();
});
```

#### Pattern 2: Multiple Users

```javascript
test('should share collection', async () => {
  // Setup: Create two users
  const [{ user: user1, token: token1 }, { user: user2, token: token2 }] 
    = await createMultipleUsers(2);
  
  // Execute: User 1 creates collection
  const response1 = await request(app)
    .post('/api/collections')
    .set('Authorization', `Bearer ${token1}`)
    .send({ name: 'My Collection' });
  
  // Execute: User 2 tries to access (should fail)
  const response2 = await request(app)
    .get(`/api/collections/${response1.body._id}`)
    .set('Authorization', `Bearer ${token2}`);
  
  // Verify
  expect(response2.status).toBe(403);
});
```

#### Pattern 3: Custom User Data

```javascript
test('should send email to verified user', async () => {
  // Setup: Create user with specific data
  const { user, token } = await createAuthenticatedUser({
    email: 'specific@example.com',
    emailVerified: true
  });
  
  // Execute: Send email
  const response = await request(app)
    .post('/api/send-email')
    .set('Authorization', `Bearer ${token}`);
  
  // Verify
  expect(response.status).toBe(200);
  expect(mockSendMail).toHaveBeenCalledWith(
    expect.objectContaining({ to: 'specific@example.com' })
  );
});
```

### Test Lifecycle Hooks

```javascript
describe('Feature Tests', () => {
  // Optional: Clean up before all tests
  beforeAll(async () => {
    await User.deleteMany({ testUser: true });
  });
  
  // Clean up after each test
  afterEach(async () => {
    await cleanupTestUsers();
  });
  
  // Optional: Final cleanup
  afterAll(async () => {
    await User.deleteMany({ testUser: true });
  });
  
  test('test 1', async () => {
    const { user, token } = await createAuthenticatedUser();
    // Test logic...
  });
  
  test('test 2', async () => {
    const { user, token } = await createAuthenticatedUser();
    // Test logic...
  });
});
```

---

## Dependency Update Strategy

### Update Approach

```
┌─────────────────────────────────────────────────────┐
│           Dependency Update Process                 │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Step 1: Audit                                     │
│  ┌──────────────────────────────────────────┐     │
│  │ • Run npm audit                          │     │
│  │ • Check npm outdated                     │     │
│  │ • Review changelogs                      │     │
│  │ • Identify breaking changes              │     │
│  └──────────────────────────────────────────┘     │
│                    ↓                                │
│  Step 2: Plan Updates                              │
│  ┌──────────────────────────────────────────┐     │
│  │ • Security fixes first                   │     │
│  │ • Patch updates next                     │     │
│  │ • Minor updates (if no breaking changes) │     │
│  │ • Defer major updates                    │     │
│  └──────────────────────────────────────────┘     │
│                    ↓                                │
│  Step 3: Update One at a Time                      │
│  ┌──────────────────────────────────────────┐     │
│  │ • Update single package                  │     │
│  │ • Run tests                              │     │
│  │ • Fix any issues                         │     │
│  │ • Commit                                 │     │
│  │ • Repeat                                 │     │
│  └──────────────────────────────────────────┘     │
│                    ↓                                │
│  Step 4: Validate                                  │
│  ┌──────────────────────────────────────────┐     │
│  │ • Run full test suite                    │     │
│  │ • Run security audit                     │     │
│  │ • Build application                      │     │
│  │ • Test in staging                        │     │
│  └──────────────────────────────────────────┘     │
│                    ↓                                │
│  Step 5: Document                                  │
│  ┌──────────────────────────────────────────┐     │
│  │ • Update dependency log                  │     │
│  │ • Document breaking changes              │     │
│  │ • Create migration notes                 │     │
│  │ • Update documentation                   │     │
│  └──────────────────────────────────────────┘     │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### Priority Order

```
Priority 1: Security Vulnerabilities (CRITICAL)
├── nodemailer (security vulnerability)
├── Other packages with high/critical CVEs
└── Apply immediately

Priority 2: Breaking Changes (HIGH)
├── happy-dom v15+ migration
├── Review migration guides
└── Test thoroughly

Priority 3: Patch Updates (MEDIUM)
├── Bug fixes
├── Performance improvements
└── Low risk, apply quickly

Priority 4: Minor Updates (LOW)
├── New features
├── Non-critical improvements
└── Review and apply if safe
```

### Package-Specific Plans

#### nodemailer Update

```javascript
// Current: 6.7.x (vulnerable)
// Target: 6.9.x (patched)

// No breaking changes expected
// Update process:
// 1. npm install nodemailer@latest
// 2. Run email tests
// 3. Verify email sending works
// 4. Check for deprecation warnings
```

#### happy-dom Update

```javascript
// Current: 12.x
// Target: 15.x (breaking changes)

// Breaking changes:
// - API changes for DOM manipulation
// - Config changes for Vitest
// - Mock implementation updates

// Migration steps:
// 1. Review migration guide
// 2. Update vitest.config.js
// 3. Update component tests
// 4. Fix any failing tests
// 5. Verify all UI tests pass
```

### Version Pinning Strategy

```json
{
  "dependencies": {
    // Critical packages: Exact versions
    "express": "4.19.2",
    "mongoose": "8.2.0",
    "jsonwebtoken": "9.0.2",
    
    // Standard packages: Patch updates allowed
    "bcryptjs": "~2.4.3",
    "joi": "~17.12.0",
    "nodemailer": "~6.9.0",
    
    // Dev dependencies: Minor updates allowed
    "jest": "^29.7.0",
    "eslint": "^8.56.0",
    "prettier": "^3.2.0"
  }
}
```

---

## Code Quality Improvements

### Mongoose Warning Fix

#### Problem

```javascript
// Warning: Index already exists with different options
// Caused by duplicate index definition

// In User model
username: { type: String, unique: true, index: true }
// ^ Duplicate index: one from 'unique', one from 'index'
```

#### Solution

```javascript
// Remove redundant index option
username: { type: String, unique: true }
// ^ unique already creates an index
```

### Error Handling Improvements

#### Current State

```javascript
// ❌ Inconsistent error handling
router.post('/api/recipes', async (req, res) => {
  try {
    const recipe = await Recipe.create(req.body);
    res.json(recipe);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

#### Improved Version

```javascript
// ✅ Consistent error handling
router.post('/api/recipes', async (req, res) => {
  try {
    const recipe = await Recipe.create(req.body);
    res.status(201).json(recipe);
  } catch (error) {
    logger.error('Recipe creation failed', { error: error.message });
    
    if (error.name === 'ValidationError') {
      return res.status(400).json({ 
        error: 'Validation failed', 
        details: error.errors 
      });
    }
    
    res.status(500).json({ 
      error: 'Failed to create recipe' 
    });
  }
});
```

### Code Cleanup Tasks

```
1. Remove Unused Code
   ├── Unused imports
   ├── Unused functions
   ├── Commented code
   └── Dead code paths

2. Improve Documentation
   ├── Add JSDoc comments
   ├── Update inline comments
   ├── Document complex logic
   └── Add examples

3. Refactor Complex Functions
   ├── Extract helper functions
   ├── Reduce nesting
   ├── Simplify conditionals
   └── Improve readability

4. Standardize Patterns
   ├── Consistent error handling
   ├── Consistent response format
   ├── Consistent validation
   └── Consistent logging
```

---

## Developer Experience Enhancements

### Pre-commit Hooks

```javascript
// .husky/pre-commit

#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Run linting
echo "Running ESLint..."
npm run lint

# Check formatting
echo "Checking code formatting..."
npm run format:check

# Run quick tests (unit tests only)
echo "Running unit tests..."
npm run test:unit

# If any fail, prevent commit
```

### CI/CD Enhancements

```yaml
# .github/workflows/test.yml

name: Test Suite

on: [push, pull_request]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm run lint
  
  test:
    runs-on: ubuntu-latest
    services:
      mongodb:
        image: mongo:7
        ports:
          - 27017:27017
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm test
      - run: npm run test:integration
    
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm audit --production
```

### Documentation Improvements

```
Documentation Updates:
├── Test Helper Guide
│   ├── How to use auth helpers
│   ├── Common patterns
│   ├── Troubleshooting
│   └── Examples
│
├── Testing Best Practices
│   ├── Test isolation
│   ├── Async handling
│   ├── Database cleanup
│   └── CI/CD integration
│
├── Dependency Management
│   ├── Update process
│   ├── Version strategy
│   ├── Security considerations
│   └── Breaking change handling
│
└── Developer Setup Guide
    ├── Environment setup
    ├── Running tests
    ├── Pre-commit hooks
    └── Troubleshooting
```

---

## Implementation Plan

### Phase 1: Test Infrastructure (Days 1-3)

**Day 1**:
- Create authentication helper module
- Add helper tests
- Update helper documentation

**Day 2**:
- Fix failures in account-management.test.js
- Fix failures in cloud-backup.test.js
- Fix failures in collections.test.js

**Day 3**:
- Fix remaining test files
- Validate all tests pass
- Update CI/CD

### Phase 2: Dependency Updates (Days 4-5)

**Day 4**:
- Update nodemailer
- Update mongoose
- Test thoroughly

**Day 5**:
- Update happy-dom
- Handle breaking changes
- Validate all tests

### Phase 3: Code Quality (Days 6-7)

**Day 6**:
- Fix Mongoose warnings
- Improve error handling
- Code cleanup

**Day 7**:
- Refactor complex code
- Update documentation
- Final validation

### Phase 4: Developer Experience (Day 8)

- Set up pre-commit hooks
- Enhance CI/CD
- Update developer guides

### Phase 5: Review & Release (Day 9-10)

**Day 9**:
- Comprehensive testing
- Code review
- Documentation review

**Day 10**:
- Final validation
- Release preparation
- Deploy V2.3.0

---

## Success Criteria

### Technical Criteria
- ✅ All 22 tests passing
- ✅ 0 high/critical vulnerabilities
- ✅ Test execution < 30 seconds
- ✅ No Mongoose warnings
- ✅ CI/CD passing

### Quality Criteria
- ✅ Code maintainability: High
- ✅ Test reliability: 100%
- ✅ Documentation: Complete
- ✅ Developer satisfaction: High

---

## Risks & Mitigation

### Technical Risks

**Risk**: Dependency updates break tests
- **Mitigation**: Update one at a time, test thoroughly
- **Fallback**: Revert individual updates

**Risk**: Test fixes introduce regressions
- **Mitigation**: Comprehensive test suite validation
- **Fallback**: Existing tests catch issues

### Process Risks

**Risk**: Taking too long
- **Mitigation**: Time-box each phase
- **Fallback**: Ship critical fixes first (Phase 1)

---

## Conclusion

This design provides a clear path to resolving technical debt in V2.3.0 while maintaining backwards compatibility and improving developer experience. The phased approach allows for incremental progress and validation at each step.

---

**Document Status**: ✅ Complete  
**Next Phase**: Development (Phase 4 of SDLC)  
**Created**: February 17, 2026  
**Last Updated**: February 17, 2026